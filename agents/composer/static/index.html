<!DOCTYPE html>
<html>

<head>
    <title>Agent Context Monitor (Standalone)</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .context-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            border-left: 2px solid #e9ecef;
            margin-left: 20px;
        }

        .context-container:before {
            content: '';
            position: absolute;
            top: 0;
            left: -20px;
            width: 18px;
            height: 30px;
            border-bottom: 2px solid #e9ecef;
        }

        .context-container:first-child:before {
            display: none;
        }

        .context-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .context-id {
            font-family: monospace;
            color: #666;
        }

        .status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: 500;
            text-transform: uppercase;
            color: white;
            letter-spacing: 0.5px;
        }

        .status-running {
            background: #ffc107;
            /* Yellow */
        }

        .status-complete {
            background: #28a745;
            /* Green */
        }

        .status-error {
            background: #dc3545;
            /* Red */
        }

        .status-cancelled {
            background: #6c757d;
            /* Gray */
        }

        .event-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .event {
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .event-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 12px;
            cursor: pointer;
        }

        .event-timestamp {
            color: #666;
            font-size: 0.9em;
            white-space: nowrap;
        }

        .event-type {
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 3px;
            background: #e9ecef;
            color: #495057;
            font-size: 0.9em;
        }

        .event-data {
            margin-top: 8px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .event-data-label {
            color: #666;
            font-size: 0.85em;
            margin-bottom: 4px;
        }

        pre {
            background: #f1f3f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 0;
            border: 1px solid #dee2e6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .connection-status.connected {
            background: #d4edda;
            color: #155724;
        }

        .connection-status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .collapse-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            color: #666;
            font-size: 0.9em;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .collapse-button:hover {
            background: #f0f0f0;
            border-radius: 4px;
        }

        .collapse-icon {
            transition: transform 0.2s;
            font-size: 0.8em;
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .context-content.collapsed,
        .event-content.collapsed {
            display: none;
        }

        .settings-panel {
            background: white;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 10px;
            align-items: center;
        }

        .action-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background: #0056b3;
        }

        .json-key {
            color: #d63384;
        }

        .json-string {
            color: #198754;
        }

        .json-number {
            color: #0d6efd;
        }

        .json-boolean {
            color: #dc3545;
        }

        .json-null {
            color: #6c757d;
        }

        .copy-button {
            float: right;
            padding: 4px 8px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 16px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .copy-button:hover {
            opacity: 1;
        }

        .event,
        .context-header {
            position: relative;
        }

        .event-content {
            margin-right: 30px;
            /* Make room for copy button */
        }

        .context {
            position: relative;
        }

        .context-header {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 10px;
        }

        .context-id-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-section {
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .section-header {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 1em;
            font-weight: 600;
        }

        .contexts>.context-container {
            border-left: none;
            margin-left: 0;
        }

        .contexts>.context-container:before {
            display: none;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .section-header:hover {
            background-color: #f0f0f0;
        }

        .event-header {
            display: grid;
            grid-template-columns: 20px auto 1fr;
            gap: 12px;
        }

        .event-timestamp {
            text-align: right;
            color: #666;
        }

        .connection-pill {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: auto;
        }

        .connection-pill.connected {
            background: #d4edda;
            color: #155724;
        }

        .connection-pill.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .context-name {
            color: #495057;
            font-weight: 500;
            margin: 0 12px;
            padding: 2px 8px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .search-input {
            justify-self: center;
            width: 400px;
            padding: 8px 12px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .event.highlight {
            background-color: #fff3cd;
            border-left: 3px solid #ffc107;
        }

        .event.highlight .event-data pre {
            background-color: #fff8e6;
        }
    </style>
</head>

<body>
    <div id="app">
        <div class="settings-panel">
            <span :class="['connection-pill', connectionClass]">{{ connectionStatus }}</span>
            <input type="text" v-model="searchQuery" placeholder="Search events..." class="search-input">
        </div>

        <div class="contexts">
            <context-view v-for="context in rootContexts" :key="context.id" :context="context" :contexts="contexts"
                :settings="settings" :depth="0"></context-view>
        </div>
    </div>

    <script>
        const { createApp } = Vue

        // Event component - Define before ContextView since ContextView uses it
        const EventView = {
            name: 'EventView',  // Add component name
            props: ['event', 'settings', 'context-id'],
            data() {
                return {
                    isExpanded: true  // Default events to expanded
                }
            },
            computed: {
                isMatch() {
                    if (!this.$root.searchQuery) return false;
                    const query = this.$root.searchQuery.toLowerCase();

                    // Check event type
                    if (this.event.type.toLowerCase().includes(query)) return true;

                    // Check event data
                    if (!this.event.data) return false;

                    const searchInObject = (obj) => {
                        if (typeof obj !== 'object') {
                            return String(obj).toLowerCase().includes(query);
                        }

                        for (let key in obj) {
                            const value = obj[key];
                            if (typeof value === 'object' && value !== null) {
                                if (searchInObject(value)) return true;
                            } else if (String(value).toLowerCase().includes(query)) {
                                return true;
                            }
                        }
                        return false;
                    };

                    let data = this.event.data;
                    if (typeof data === 'string') {
                        try {
                            data = JSON.parse(data);
                        } catch (e) {
                            return data.toLowerCase().includes(query);
                        }
                    }

                    return searchInObject(data);
                }
            },
            methods: {
                formatTimestamp(timestamp) {
                    return new Date(timestamp * 1000).toLocaleString()
                },
                formatEventData(event) {
                    if (!event.data) return ''

                    try {
                        let data = event.data
                        // Try to parse if it's a JSON string
                        if (typeof data === 'string' && (data.startsWith('{') || data.startsWith('['))) {
                            try {
                                data = JSON.parse(data)
                            } catch (e) {
                                // If parsing fails, use the original string
                                console.log('Failed to parse JSON:', e)
                            }
                        }

                        switch (event.type) {
                            case 'agent_prompt':
                                return this.formatPromptData(data)
                            case 'agent_tool_calls':
                                return this.formatToolCallsData(data)
                            default:
                                return syntaxHighlightJson(data)
                        }
                    } catch (e) {
                        console.log('Error formatting event data:', e)
                        return String(event.data)
                    }
                },
                formatPromptData(data) {
                    if (Array.isArray(data)) {
                        return data.map(msg => `${msg.role}: ${msg.content}`).join('\n\n')
                    }
                    return JSON.stringify(data, null, 2)
                },
                formatToolCallsData(data) {
                    try {
                        if (typeof data === 'string') {
                            data = JSON.parse(data)
                        }

                        if (data.tool_calls) {
                            return data.tool_calls.map(call => {
                                if (Array.isArray(call)) {
                                    // Handle the [name, args] format
                                    const [name, args] = call
                                    return `${name}(${JSON.stringify(args, null, 2)})`
                                } else {
                                    // Handle object format
                                    return `${call.name}(${JSON.stringify(call.args, null, 2)})`
                                }
                            }).join('\n\n')
                        }
                        return syntaxHighlightJson(data)
                    } catch (e) {
                        console.log('Error formatting tool calls:', e)
                        return JSON.stringify(data, null, 2)
                    }
                },
                copyEvent() {
                    const eventJson = JSON.stringify(this.event, null, 2);
                    navigator.clipboard.writeText(eventJson);
                }
            },
            template: `
                <li :class="['event', { highlight: isMatch }]">
                    <div class="event-header" @click="isExpanded = !isExpanded">
                        <span class="collapse-icon">{{ isExpanded ? 'âˆ’' : '+' }}</span>
                        <span class="event-type">{{ event.type }}</span>
                        <span class="event-timestamp">{{ formatTimestamp(event.timestamp) }}</span>
                    </div>
                    <button class="copy-button" @click.stop="copyEvent">ðŸ“‹</button>
                    <div :class="['event-content', { collapsed: !isExpanded }]">
                        <div v-if="event.data" class="event-data">
                            <div class="event-data-label">Event Data:</div>
                            <pre v-html="formatEventData(event)"></pre>
                        </div>
                    </div>
                </li>
            `,
            mounted() {
                window.addEventListener('updateExpansion', (e) => {
                    if (e.detail.contextId === this.contextId) {
                        this.isExpanded = e.detail.expanded;
                    }
                });
            },
            unmounted() {
                window.removeEventListener('updateExpansion', this.handleExpansion);
            }
        }

        // Context component
        const ContextView = {
            name: 'ContextView',
            components: {
                EventView
            },
            props: ['context', 'settings', 'depth', 'contexts'],
            data() {
                return {
                    isExpanded: this.settings.expandedByDefault,
                    isEventsExpanded: false,  // Events section starts collapsed
                    isOutputExpanded: true    // Output section starts expanded
                }
            },
            methods: {
                getChildContexts(parentId) {
                    if (!this.contexts) return [];
                    return Array.from(this.contexts.values())
                        .filter(context => context.parent_id === parentId);
                },
                copyContext() {
                    const contextData = {
                        id: this.context.id,
                        name: this.context.name,
                        parent_id: this.context.parent_id,
                        status: this.context.status,
                        output: this.context.output,
                        error: this.context.error,
                        created_at: this.context.created_at,
                        events: this.context.history || [], // Map history to events
                        children: [] // Will be populated as we process child contexts
                    };
                    navigator.clipboard.writeText(JSON.stringify(contextData, null, 2));
                },
                formatOutput(output) {
                    if (!output) return '';
                    try {
                        if (typeof output === 'string') {
                            // Try to parse if it looks like JSON
                            if (output.trim().startsWith('{') || output.trim().startsWith('[')) {
                                try {
                                    const parsed = JSON.parse(output);
                                    return syntaxHighlightJson(parsed);
                                } catch {
                                    return output;
                                }
                            }
                            return output;
                        }
                        return syntaxHighlightJson(output);
                    } catch (e) {
                        return String(output);
                    }
                },
                formatTimestamp(timestamp) {
                    if (!timestamp) return 'N/A';
                    return new Date(timestamp * 1000).toLocaleString();
                },
                getCreationTime() {
                    if (this.context.events) {
                        const createdEvent = this.context.events.find(e => e.type === 'context_created');
                        if (createdEvent) {
                            return createdEvent.data.timestamp;
                        }
                        if (this.context.events.length > 0) {
                            return Math.min(...this.context.events.map(e => e.timestamp));
                        }
                    }
                    return null;
                },
                getLastEventTime() {
                    if (this.context.events && this.context.events.length > 0) {
                        return Math.max(...this.context.events.map(e => e.timestamp));
                    }
                    return null;
                },
                handleContextEvent(event) {
                    switch (event.type) {
                        case 'context_update':
                            // Handle context updates (e.g., name changes)
                            if (event.data.name) {
                                this.context.name = event.data.name;
                            }
                            break;

                        case 'context_exception':
                            // Handle context exceptions
                            this.context.status = 'error';
                            this.context.error = event.data;
                            break;

                        case 'context_output':
                            // Handle context output updates
                            this.context.output = event.data;
                            this.context.status = 'success';
                            break;
                    }
                },
                expandAllEvents() {
                    this.isEventsExpanded = true;
                    // Set all events in this context to expanded
                    window.dispatchEvent(new CustomEvent('updateExpansion', {
                        detail: {
                            expanded: true,
                            contextId: this.context.id
                        }
                    }));
                },
                collapseAllEvents() {
                    this.isEventsExpanded = false;
                    // Set all events in this context to collapsed
                    window.dispatchEvent(new CustomEvent('updateExpansion', {
                        detail: {
                            expanded: false,
                            contextId: this.context.id
                        }
                    }));
                },
                copyOutput() {
                    const output = this.context.output;
                    if (typeof output === 'object') {
                        navigator.clipboard.writeText(JSON.stringify(output, null, 2));
                    } else {
                        navigator.clipboard.writeText(String(output));
                    }
                },
                getEvents() {
                    return (this.context.events || []).filter(event =>
                        !['context_update'].includes(event.type)
                    );
                }
            },
            template: `
                <div class="context-container" :style="{ marginLeft: depth * 20 + 'px' }">
                    <div class="context-header">
                        <span :class="['status', 'status-' + context.status]">{{ context.status }}</span>
                        <div class="context-id-section">
                            <button class="collapse-button" @click="isExpanded = !isExpanded">
                                <span class="collapse-icon"><b>{{ isExpanded ? 'âˆ’' : '+' }}</b></span>
                                <span class="context-id">Context {{ context.id }}</span>
                            </button>
                            <span v-if="context.name" class="context-name">{{ context.name }}</span>
                            <span class="context-timestamps">
                                Created: {{ formatTimestamp(context.created_at) }}
                            </span>
                        </div>
                        <button class="copy-button" @click.stop="copyContext">ðŸ“‹</button>
                    </div>
                    <div v-if="isExpanded">
                        <div class="context-content">
                            <!-- Error section -->
                            <div v-if="context.error" class="context-section error-section">
                                <div class="section-header">
                                    <span>Error</span>
                                </div>
                                <pre class="error-content">{{ context.error }}</pre>
                            </div>
                            
                            <!-- Events section -->
                            <div v-if="getEvents().length > 0" class="context-section">
                                <div class="section-header" style="cursor: pointer;">
                                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                                        <span>Events ({{ getEvents().length }})</span>
                                        <div style="display: flex; gap: 10px;">
                                            <button @click="expandAllEvents" class="action-button" style="padding: 2px 8px;"><b>+</b></button>
                                            <button @click="collapseAllEvents" class="action-button" style="padding: 2px 8px;"><b>âˆ’</b></button>
                                        </div>
                                    </div>
                                </div>
                                <ul v-show="isEventsExpanded" class="event-list">
                                    <event-view
                                        v-for="event in getEvents()"
                                        :key="event.timestamp"
                                        :event="event"
                                        :settings="settings"
                                        :context-id="context.id"
                                    ></event-view>
                                </ul>
                            </div>
                            
                            <!-- Output section -->
                            <div v-if="context.output" class="context-section">
                                <div class="section-header" @click="isOutputExpanded = !isOutputExpanded" style="cursor: pointer;">
                                    <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                                        <span>Output</span>
                                        <button class="copy-button" @click.stop="copyOutput">ðŸ“‹</button>
                                    </div>
                                </div>
                                <pre v-show="isOutputExpanded" v-html="formatOutput(context.output)"></pre>
                            </div>
                        </div>
                        <!-- Child contexts -->
                        <context-view
                            v-for="childContext in getChildContexts(context.id)"
                            :key="childContext.id"
                            :context="childContext"
                            :contexts="contexts"
                            :settings="settings"
                            :depth="depth + 1"
                        ></context-view>
                    </div>
                </div>
            `
        }

        // Add this utility function before the app definition
        function syntaxHighlightJson(json) {
            if (typeof json !== 'string') {
                json = JSON.stringify(json, null, 2);
            }
            return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                let cls = 'json-number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'json-key';
                    } else {
                        cls = 'json-string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'json-boolean';
                } else if (/null/.test(match)) {
                    cls = 'json-null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }

        // Add this in the <script> section, before other code
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(
                () => {
                    // Optional: Show a brief "Copied!" tooltip
                    console.log('Copied to clipboard');
                },
                (err) => {
                    console.error('Failed to copy:', err);
                }
            );
        }

        // Modify the createEventElement function
        function createEventElement(event) {
            const eventDiv = document.createElement('div');
            eventDiv.className = 'event';

            // Create copy button
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.innerHTML = 'ðŸ“‹'; // Clipboard emoji
            copyButton.onclick = () => copyToClipboard(JSON.stringify(event, null, 2));

            // Create event content div
            const contentDiv = document.createElement('div');
            contentDiv.className = 'event-content';
            contentDiv.textContent = formatEvent(event);

            eventDiv.appendChild(copyButton);
            eventDiv.appendChild(contentDiv);
            return eventDiv;
        }

        // Modify the createContextElement function
        function createContextElement(context) {
            const contextDiv = document.createElement('div');
            contextDiv.className = 'context';

            const headerDiv = document.createElement('div');
            headerDiv.className = 'context-header';

            // Create copy button for context
            const copyButton = document.createElement('button');
            copyButton.className = 'copy-button';
            copyButton.innerHTML = 'ðŸ“‹';
            copyButton.onclick = () => copyToClipboard(JSON.stringify(context, null, 2));

            // Rest of your existing context creation code...
            headerDiv.appendChild(copyButton);
            // Add your existing header content...

            contextDiv.appendChild(headerDiv);
            // Rest of your context creation code...

            return contextDiv;
        }

        const app = createApp({
            components: {
                ContextView,
                EventView
            },
            data() {
                return {
                    contexts: new Map(),
                    contextParentMap: new Map(),
                    ws: null,
                    retryCount: 0,
                    settings: {
                        expandedByDefault: true
                    },
                    wsStatus: 'disconnected',
                    searchQuery: ''
                }
            },
            template: `
                <div>
                    <div class="settings-panel">
                        <span :class="['connection-pill', connectionClass]">{{ connectionStatus }}</span>
                        <input 
                            type="text" 
                            v-model="searchQuery" 
                            placeholder="Search events..." 
                            class="search-input"
                        >
                    </div>

                    <div class="contexts">
                        <context-view
                            v-for="context in rootContexts"
                            :key="context.id"
                            :context="context"
                            :contexts="contexts"
                            :settings="settings"
                            :depth="0"
                        ></context-view>
                    </div>
                </div>
            `,
            computed: {
                connectionStatus() {
                    return this.wsStatus === 'connected' ? 'Connected' : 'Disconnected'
                },
                connectionClass() {
                    return this.wsStatus
                },
                rootContexts() {
                    if (!this.contexts) return [];
                    return Array.from(this.contexts.values())
                        .filter(context => !context.parent_id);
                }
            },
            methods: {
                getChildContexts(parentId) {
                    if (!this.contexts) return [];
                    return Array.from(this.contexts.values())
                        .filter(context => context.parent_id === parentId);
                },
                setupWebSocket() {
                    try {
                        if (this.ws) {
                            this.ws.close()
                            this.ws = null
                        }

                        const ws = new WebSocket('ws://localhost:9001/ws')
                        this.ws = ws

                        ws.onopen = () => {
                            console.log('WebSocket connected')
                            this.wsStatus = 'connected'
                            this.retryCount = 0
                        }

                        ws.onmessage = (event) => {
                            const data = JSON.parse(event.data)
                            console.log('Received message:', data)
                            if (data.type === 'context_init') {
                                this.initContext(data)
                            } else {
                                this.updateContext(data)
                            }
                        }

                        ws.onclose = () => {
                            console.log('WebSocket closed')
                            this.wsStatus = 'disconnected'
                            this.retryCount++
                            const backoffTime = Math.min(1000 * Math.pow(2, this.retryCount - 1), 5000)
                            setTimeout(() => this.setupWebSocket(), backoffTime)
                        }

                        ws.onerror = (error) => {
                            console.log('WebSocket error:', error)
                            ws.close()
                        }
                    } catch (error) {
                        console.log('Failed to connect:', error)
                        this.wsStatus = 'disconnected'
                        setTimeout(() => this.setupWebSocket(), 1000)
                    }
                },
                initContext(data) {
                    if (!this.contexts.has(data.context_id)) {
                        // Create the new context
                        const newContext = {
                            id: data.context_id,
                            parent_id: data.parent_id,
                            name: data.name || null,  // Add name field
                            status: data.status || 'running',
                            output: data.output || null,
                            error: data.error || null,
                            created_at: data.created_at || null,
                            history: data.history || [],
                            children: []
                        };

                        // Add it to our contexts map
                        this.contexts.set(data.context_id, newContext);

                        // If this context has a parent, update the parent's children
                        if (data.parent_id && this.contexts.has(data.parent_id)) {
                            const parentContext = this.contexts.get(data.parent_id);
                            if (!parentContext.children.includes(data.context_id)) {
                                parentContext.children.push(data.context_id);
                            }
                        }

                        // Update the parent map for quick lookups
                        this.contextParentMap.set(data.context_id, data.parent_id);

                        // Force update to trigger reactivity
                        this.contexts = new Map(this.contexts);
                    }
                },
                updateContext(data) {
                    if (data.type === 'context') {
                        // Handle full context state update
                        const contextData = data.data || data; // Handle both {type:'context', data:{...}} and direct context data
                        const contextId = contextData.id;

                        // Skip if we've already processed this context in this update cycle
                        if (this._processingContexts && this._processingContexts.has(contextId)) {
                            return;
                        }

                        // Initialize processing set if needed
                        if (!this._processingContexts) {
                            this._processingContexts = new Set();
                        }
                        this._processingContexts.add(contextId);

                        const context = {
                            id: contextId,
                            name: contextData.name,
                            parent_id: contextData.parent_id,
                            status: contextData.status,
                            output: contextData.output,
                            error: contextData.error,
                            created_at: contextData.created_at,
                            events: contextData.history || [], // Map history to events
                            children: [] // Will be populated as we process child contexts
                        };

                        // Add/update context in our map
                        this.contexts.set(contextId, context);

                        // Update parent relationships
                        if (context.parent_id && this.contexts.has(context.parent_id)) {
                            const parentContext = this.contexts.get(context.parent_id);
                            if (!parentContext.children.includes(contextId)) {
                                parentContext.children.push(contextId);
                            }
                        }

                        // Process any child contexts
                        if (contextData.children) {
                            contextData.children.forEach(childContext => {
                                this.updateContext({
                                    type: 'context',
                                    data: childContext
                                });
                            });
                        }

                        // Clean up processing set if this is the root call
                        if (this._processingContexts.size === 1) {
                            this._processingContexts = null;
                        } else {
                            this._processingContexts.delete(contextId);
                        }

                    } else if (data.type === 'event') {
                        // Handle individual event updates
                        const contextId = data.context_id;
                        const eventData = data.data;

                        if (!this.contexts.has(contextId)) {
                            console.warn(`Received event for unknown context ${contextId}`);
                            return;
                        }

                        const context = this.contexts.get(contextId);
                        context.events.push(eventData);

                        // Update context based on event type
                        switch (eventData.type) {
                            case 'context_update':
                                // Handle all fields in the context update data
                                if (eventData.data) {
                                    Object.entries(eventData.data).forEach(([key, value]) => {
                                        if (key in context) {
                                            context[key] = value;
                                            console.log(`Updated context ${contextId} ${key} to:`, value);
                                        }
                                    });
                                }
                                break;
                            case 'context_exception':
                                context.status = 'error';
                                context.error = eventData.data;
                                break;
                            case 'context_output':
                                context.status = 'complete';
                                context.output = eventData.data;
                                break;
                        }

                        // Force a reactive update
                        this.contexts.set(contextId, { ...context });
                        this.contexts = new Map(this.contexts);
                    }
                },
                expandAll() {
                    this.settings.expandedByDefault = true;
                    this.updateAllExpansionStates(true);
                },
                collapseAll() {
                    this.settings.expandedByDefault = false;
                    this.updateAllExpansionStates(false);
                },
                updateAllExpansionStates(expanded) {
                    // Emit a custom event that components can listen to
                    window.dispatchEvent(new CustomEvent('updateExpansion', {
                        detail: { expanded }
                    }));
                },
                getContextHierarchy(contextId) {
                    const hierarchy = [];
                    let currentId = contextId;

                    while (currentId && this.contextParentMap.has(currentId)) {
                        hierarchy.unshift(currentId);
                        currentId = this.contextParentMap.get(currentId);
                    }

                    return hierarchy;
                }
            },
            created() {
                // Initialize the contexts Map
                this.contexts = new Map();
                this.contextParentMap = new Map();
            },
            mounted() {
                this.setupWebSocket();
            }
        }).mount('#app')
    </script>
</body>

</html>